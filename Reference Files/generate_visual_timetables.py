import os
import pandas as pd
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Alignment, Font, Border, Side
from openpyxl.utils import get_column_letter
from openpyxl.worksheet.dimensions import ColumnDimension
from tqdm import tqdm
import json
from datetime import datetime, timedelta
import hashlib

# ==============================
# ENHANCED CONFIGURATION SYSTEM - UPDATED FOR 30-MIN SLOTS
# ==============================
def load_config():
    """Load configuration with enhanced defaults for 30-minute slots"""
    default_config = {
        "time_slots": {
            "start": "08:00",
            "end": "18:30",
            "slot_minutes": 30  # Changed to 30 minutes
        },
        "watermark": {
            "text": "Generated by ClassSync AI",
            "font": "Arial",
            "fontsize": 10,
            "position": "top-header",
            "color": "FF808080"
        },
        "output": {
            "xlsx_folder": "output_xlsx"
        },
        "styling": {
            "header_color": "FF4472C4",
            "day_color": "FFD9E2F3",
            "room_color": "FFF2F2F2",
            "border_style": "thin",
            "font_name": "Calibri",
            "font_size": 9,  # Smaller font for more columns
            "header_font_size": 11,
            "auto_adjust_columns": True
        },
        "colors": {},
        "export_options": {
            "include_empty_days": False,
            "merge_day_cells": True,
            "show_duration": False,
            "compact_mode": False,
            "merge_session_cells": True  # New option for merging session cells
        }
    }
    
    if os.path.exists("config.json"):
        try:
            with open("config.json", "r", encoding="utf-8") as f:
                user_config = json.load(f)
                merge_configs(default_config, user_config)
        except Exception as e:
            print(f"Warning: Could not load config.json - {e}")
            print("Using default configuration...")
    
    return default_config

def merge_configs(default, user):
    """Recursively merge user config into default config"""
    for key, value in user.items():
        if key in default and isinstance(default[key], dict) and isinstance(value, dict):
            merge_configs(default[key], value)
        else:
            default[key] = value

# ==============================
# COLOR MANAGEMENT SYSTEM - UPDATED FOR PROGRAM-BASED COLORS
# ==============================
class ColorManager:
    def __init__(self, predefined_colors=None):
        self.predefined_colors = predefined_colors or {}
        self.generated_colors = {}
        
    def get_color(self, program_name):
        """Get color for a program, generating if not exists"""
        if program_name in self.predefined_colors:
            color = self.predefined_colors[program_name]
            return self._ensure_argb_format(color)
        
        if program_name not in self.generated_colors:
            # Generate consistent color based on program name hash
            hash_object = hashlib.md5(program_name.encode())
            hash_hex = hash_object.hexdigest()
            
            # Extract RGB components and adjust for readability
            r = int(hash_hex[0:2], 16)
            g = int(hash_hex[2:4], 16)
            b = int(hash_hex[4:6], 16)
            
            # Ensure colors are readable and distinct
            r = max(120, min(200, r))
            g = max(120, min(200, g))
            b = max(120, min(200, b))
            
            # Adjust saturation for better distinction
            if r > g and r > b:
                r = min(255, r + 30)
            elif g > r and g > b:
                g = min(255, g + 30)
            else:
                b = min(255, b + 30)
            
            color_hex = f"FF{r:02X}{g:02X}{b:02X}"
            self.generated_colors[program_name] = color_hex
        
        return self.generated_colors[program_name]
    
    def _ensure_argb_format(self, color):
        """Ensure color is in ARGB format"""
        if isinstance(color, str):
            color = color.upper().replace('#', '')
            if len(color) == 6:
                return f"FF{color}"
            elif len(color) == 8:
                return color
            else:
                return "FFFFFFFF"
        return "FFFFFFFF"
    
    def get_all_colors(self):
        """Get all colors used"""
        return {**self.predefined_colors, **self.generated_colors}

# ==============================
# TIME SLOT GENERATION - UPDATED FOR 30-MIN SLOTS
# ==============================
def generate_time_slots(config):
    """Generate 30-minute time slots from 8:00 to 18:30"""
    start_time = datetime.strptime(config["time_slots"]["start"], "%H:%M")
    end_time = datetime.strptime(config["time_slots"]["end"], "%H:%M")
    slot_minutes = config["time_slots"]["slot_minutes"]
    
    time_slots = []
    current_time = start_time
    
    while current_time < end_time:
        slot_end = current_time + timedelta(minutes=slot_minutes)
        if slot_end > end_time:
            break
        time_slots.append(f"{current_time.strftime('%H:%M')}-{slot_end.strftime('%H:%M')}")
        current_time = slot_end
    
    return time_slots

# ==============================
# DATA PROCESSING - UPDATED FOR SESSION MERGING
# ==============================
def process_csv_data(filepath, time_slots, config):
    """Process CSV data and organize into timetable structure with session merging"""
    try:
        df = pd.read_csv(filepath, encoding='utf-8')
    except UnicodeDecodeError:
        try:
            df = pd.read_csv(filepath, encoding='latin-1')
        except Exception as e:
            print(f"Error reading {filepath}: {e}")
            return None
    
    # Clean column names
    df.columns = df.columns.str.strip()
    
    # Map Course_Key to Course_Name if needed
    if 'Course_Key' in df.columns and 'Course_Name' not in df.columns:
        df['Course_Name'] = df['Course_Key']
    
    # Ensure required columns exist
    required_columns = ["Course_Name", "Instructor", "Section", "Program", "Weekday", "Start_Time", "End_Time", "Room"]
    missing_columns = [col for col in required_columns if col not in df.columns]
    
    if missing_columns:
        print(f"Missing columns in {filepath}: {missing_columns}")
        return None
    
    # Select and clean required columns
    df = df[required_columns].copy()
    df = df.dropna(subset=["Course_Name", "Weekday", "Start_Time", "End_Time", "Room"])
    
    # Structure: {Day -> {Room -> sessions_list}}
    weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    sessions_data = {day: {} for day in weekdays}
    
    for _, row in df.iterrows():
        day = row["Weekday"].strip()
        room = str(row["Room"]).strip()
        
        if day not in weekdays:
            continue
            
        if room not in sessions_data[day]:
            sessions_data[day][room] = []
        
        try:
            start = datetime.strptime(str(row["Start_Time"]).strip(), "%H:%M")
            end = datetime.strptime(str(row["End_Time"]).strip(), "%H:%M")
        except ValueError as e:
            print(f"Invalid time format in {filepath}: {row['Start_Time']} - {row['End_Time']}")
            continue
        
        # Create session info with slot positions
        session_info = {
            "course": str(row["Course_Name"]).strip(),
            "section": str(row["Section"]).strip(),
            "program": str(row["Program"]).strip(),
            "instructor": str(row["Instructor"]).strip(),
            "start_time": start,
            "end_time": end,
            "duration_minutes": int((end - start).total_seconds() / 60)
        }
        
        sessions_data[day][room].append(session_info)
    
    # Convert to grid format with merged cells
    return convert_to_grid_with_merging(sessions_data, time_slots)

def convert_to_grid_with_merging(sessions_data, time_slots):
    """Convert session data to grid format with cell merging information"""
    grid = {}
    
    for day in sessions_data:
        grid[day] = {}
        
        for room, sessions in sessions_data[day].items():
            grid[day][room] = {slot: None for slot in time_slots}
            
            # Process each session
            for session in sessions:
                start_time = session["start_time"]
                end_time = session["end_time"]
                
                # Find overlapping time slots
                overlapping_slots = []
                for slot in time_slots:
                    slot_start_str, slot_end_str = slot.split("-")
                    slot_start = datetime.strptime(slot_start_str, "%H:%M")
                    slot_end = datetime.strptime(slot_end_str, "%H:%M")
                    
                    # Check if session overlaps with this slot
                    if not (end_time <= slot_start or start_time >= slot_end):
                        overlapping_slots.append(slot)
                
                # Mark all overlapping slots with session info
                if overlapping_slots:
                    session_with_merge = {**session, "merged_slots": len(overlapping_slots)}
                    
                    for i, slot in enumerate(overlapping_slots):
                        if i == 0:  # First slot gets the full session info
                            grid[day][room][slot] = session_with_merge
                        else:  # Other slots get marked as merged
                            grid[day][room][slot] = {"merged": True, "main_session": overlapping_slots[0]}
    
    return grid

# ==============================
# EXCEL GENERATION - UPDATED FOR 30-MIN SLOTS AND MERGING
# ==============================
def create_excel_timetable(grid, time_slots, config, color_manager, filename):
    """Create formatted Excel timetable with 30-minute slots and merged cells"""
    wb = Workbook()
    ws = wb.active
    ws.title = "Timetable"
    
    # Styling configuration
    styling = config["styling"]
    border = Border(
        left=Side(style=styling["border_style"]),
        right=Side(style=styling["border_style"]),
        top=Side(style=styling["border_style"]),
        bottom=Side(style=styling["border_style"])
    )
    
    # Header styling
    header_fill = PatternFill(start_color=styling["header_color"], 
                             end_color=styling["header_color"], 
                             fill_type="solid")
    header_font = Font(name=styling["font_name"], 
                      size=styling["header_font_size"], 
                      bold=True, 
                      color="FFFFFF")
    
    # Create main header
    ws.merge_cells(start_row=1, start_column=1, end_row=1, end_column=2 + len(time_slots))
    header_text = f"ClassSync AI - {os.path.splitext(os.path.basename(filename))[0]}"
    ws['A1'] = header_text
    ws['A1'].font = Font(name=styling["font_name"], size=styling["header_font_size"] + 2, bold=True)
    ws['A1'].alignment = Alignment(horizontal='center', vertical='center')
    
    # Column headers
    headers = ["Day", "Room"] + time_slots
    for col, header in enumerate(headers, 1):
        cell = ws.cell(row=2, column=col, value=header)
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = Alignment(horizontal='center', vertical='center', text_rotation=45 if col > 2 else 0)
        cell.border = border
    
    # Populate data with merging
    current_row = 3
    weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    merged_ranges = []  # Track merged ranges to avoid conflicts
    
    for day in weekdays:
        day_rooms = grid.get(day, {})
        
        # Skip empty days if configured
        if not day_rooms and not config["export_options"]["include_empty_days"]:
            continue
        
        # If no rooms for this day, add empty row
        if not day_rooms:
            day_rooms = {"": {slot: None for slot in time_slots}}
        
        day_start_row = current_row
        
        for room, slots in day_rooms.items():
            # Day column
            ws.cell(row=current_row, column=1, value=day)
            
            # Room column  
            ws.cell(row=current_row, column=2, value=room)
            
            # Time slot columns with merging
            for col, slot in enumerate(time_slots, start=3):
                cell = ws.cell(row=current_row, column=col)
                session = slots.get(slot)
                
                if session and not session.get("merged", False):
                    # Main session cell
                    merged_slots = session.get("merged_slots", 1)
                    
                    # Format session text
                    if config["export_options"]["compact_mode"]:
                        cell_text = f"{session['course']}\n{session['section']}"
                    else:
                        duration_text = f" ({session['duration_minutes']}min)" if config["export_options"]["show_duration"] else ""
                        cell_text = f"{session['course']}\n{session['section']}\n{session['instructor']}{duration_text}"
                    
                    cell.value = cell_text
                    
                    # Apply program-based color
                    program_color = color_manager.get_color(session['program'])
                    cell.fill = PatternFill(start_color=program_color, 
                                          end_color=program_color, 
                                          fill_type="solid")
                    
                    # Text formatting
                    cell.font = Font(name=styling["font_name"], 
                                   size=styling["font_size"], 
                                   bold=False)
                    cell.alignment = Alignment(wrap_text=True, 
                                             vertical='center', 
                                             horizontal='center')
                    
                    # Merge cells for longer sessions
                    if merged_slots > 1 and config["export_options"]["merge_session_cells"]:
                        end_col = col + merged_slots - 1
                        if end_col <= 2 + len(time_slots):  # Don't exceed available columns
                            try:
                                ws.merge_cells(start_row=current_row, start_column=col, 
                                             end_row=current_row, end_column=end_col)
                                merged_ranges.append((current_row, col, current_row, end_col))
                                
                                # Apply styling to merged cells
                                for merge_col in range(col, end_col + 1):
                                    merge_cell = ws.cell(row=current_row, column=merge_col)
                                    merge_cell.fill = PatternFill(start_color=program_color, 
                                                                end_color=program_color, 
                                                                fill_type="solid")
                                    merge_cell.border = border
                            except Exception as e:
                                print(f"Warning: Could not merge cells for {session['course']}: {e}")
                
                elif not session or not session.get("merged", False):
                    # Empty cell
                    cell.value = ""
                
                cell.border = border
            
            current_row += 1
        
        # Merge day cells if enabled and there are multiple rooms
        if (config["export_options"]["merge_day_cells"] and 
            current_row > day_start_row + 1):
            ws.merge_cells(start_row=day_start_row, 
                          start_column=1, 
                          end_row=current_row - 1, 
                          end_column=1)
            
            # Style merged day cell
            day_cell = ws.cell(row=day_start_row, column=1)
            day_cell.fill = PatternFill(start_color=styling["day_color"], 
                                      end_color=styling["day_color"], 
                                      fill_type="solid")
            day_cell.font = Font(name=styling["font_name"], 
                               size=styling["font_size"] + 1, 
                               bold=True)
            day_cell.alignment = Alignment(horizontal='center', vertical='center')
            day_cell.border = border
        
        # Style room cells
        for row_idx in range(day_start_row, current_row):
            room_cell = ws.cell(row=row_idx, column=2)
            room_cell.fill = PatternFill(start_color=styling["room_color"], 
                                       end_color=styling["room_color"], 
                                       fill_type="solid")
            room_cell.font = Font(name=styling["font_name"], 
                                size=styling["font_size"], 
                                bold=True)
            room_cell.alignment = Alignment(horizontal='center', vertical='center')
            room_cell.border = border
    
    # Add watermark
    add_watermark(ws, config, current_row, len(time_slots))
    
    # Auto-adjust column widths for 30-minute slots
    if styling["auto_adjust_columns"]:
        adjust_column_widths_30min(ws, time_slots)
    
    return wb

def add_watermark(ws, config, last_row, num_time_slots):
    """Add watermark to worksheet"""
    watermark_config = config["watermark"]
    watermark_color = watermark_config.get("color", "FF808080")
    if len(watermark_color) == 6:
        watermark_color = f"FF{watermark_color}"
    
    watermark_font = Font(name=watermark_config["font"], 
                         size=watermark_config["fontsize"], 
                         italic=True, 
                         color=watermark_color[2:])
    
    if watermark_config["position"] == "top-header":
        ws['A1'] = watermark_config["text"]
        ws['A1'].font = watermark_font
        ws['A1'].alignment = Alignment(horizontal='center', vertical='center')
    else:
        last_col = get_column_letter(2 + num_time_slots)
        watermark_cell = f"{last_col}{last_row + 2}"
        ws[watermark_cell] = watermark_config["text"]
        ws[watermark_cell].font = watermark_font
        ws[watermark_cell].alignment = Alignment(horizontal='right', vertical='center')

def adjust_column_widths_30min(ws, time_slots):
    """Auto-adjust column widths optimized for 30-minute slots"""
    # Day column
    ws.column_dimensions['A'].width = 12
    
    # Room column
    ws.column_dimensions['B'].width = 15
    
    # Time slot columns - narrower for 30-minute slots
    for i, slot in enumerate(time_slots, start=3):
        col_letter = get_column_letter(i)
        ws.column_dimensions[col_letter].width = 18  # Reduced from 25 to 18
    
    # Set row heights
    for row in ws.iter_rows():
        ws.row_dimensions[row[0].row].height = 50  # Slightly reduced

# ==============================
# MAIN PROCESSING FUNCTION
# ==============================
def process_all_csv_files(config):
    """Process all CSV files and generate Excel timetables"""
    output_xlsx = config["output"]["xlsx_folder"]
    os.makedirs(output_xlsx, exist_ok=True)
    
    # Initialize color manager for program-based colors
    color_manager = ColorManager(config["colors"])
    
    # Generate 30-minute time slots
    time_slots = generate_time_slots(config)
    print(f"Generated {len(time_slots)} time slots: {time_slots[0]} to {time_slots[-1]}")
    
    # Find all CSV files
    csv_files = []
    for root, _, files in os.walk("output"):
        for file in files:
            if file.endswith(".csv"):
                csv_files.append((file, os.path.join(root, file)))
    
    if not csv_files:
        print("No CSV files found in 'output' directory!")
        return
    
    print(f"Found {len(csv_files)} CSV files to process")
    
    # Process each CSV file
    successful_exports = 0
    failed_exports = 0
    
    for file, filepath in tqdm(csv_files, desc="Generating Excel Timetables", unit="file"):
        try:
            # Process CSV data
            grid = process_csv_data(filepath, time_slots, config)
            
            if grid is None:
                failed_exports += 1
                continue
            
            # Create Excel file
            wb = create_excel_timetable(grid, time_slots, config, color_manager, file)
            
            # Save file
            output_filename = os.path.splitext(file)[0] + ".xlsx"
            output_path = os.path.join(output_xlsx, output_filename)
            wb.save(output_path)
            
            successful_exports += 1
            
        except Exception as e:
            print(f"Error processing {file}: {e}")
            failed_exports += 1
    
    # Summary
    print(f"\nExcel Export Complete!")
    print(f"   - Successfully exported: {successful_exports} files")
    print(f"   - Failed exports: {failed_exports} files")
    print(f"   - Output directory: {output_xlsx}/")
    
    # Save color mapping for programs
    save_color_mapping(color_manager, output_xlsx)

def save_color_mapping(color_manager, output_dir):
    """Save program color mapping for reference"""
    color_mapping = color_manager.get_all_colors()
    
    if color_mapping:
        mapping_file = os.path.join(output_dir, "program_color_mapping.json")
        try:
            with open(mapping_file, "w", encoding="utf-8") as f:
                json.dump(color_mapping, f, indent=2, ensure_ascii=False)
            print(f"Color mapping saved to {mapping_file}")
        except Exception as e:
            print(f"Could not save color mapping: {e}")

# ==============================
# MAIN EXECUTION
# ==============================
def main():
    """Main execution function"""
    print("ClassSync AI - Excel Timetable Generator (30-minute slots)")
    print("=" * 60)
    
    # Load configuration
    config = load_config()
    print(f"Configuration loaded")
    print(f"   - Time slots: {config['time_slots']['start']} to {config['time_slots']['end']}")
    print(f"   - Slot duration: {config['time_slots']['slot_minutes']} minutes")
    print(f"   - Output folder: {config['output']['xlsx_folder']}")
    print(f"   - Colors based on: Program")
    
    # Process files
    process_all_csv_files(config)
    
    print(f"\nComplete! Check the '{config['output']['xlsx_folder']}' directory for Excel timetables.")

if __name__ == "__main__":
    main()